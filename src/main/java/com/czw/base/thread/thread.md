
##1.同步变量的修复方式
    多线程访问状态变量的同步问题有三种可修复的方式：
	
	·不共享(unshare)
	·不可变(final)
	·同步(synchronized,volatile)


##2.无状态对象一定是线程安全的 
	
	概念：无状态就是该对象不包含任何域，其他类中域的引用.所有状态都是计算过程中的临时变量且只由当前线程访问.
	
	
##3.基础知识 
	      
###3.1.原子性：
    概念：基本数据类型除long和double外都是原子性的,另外虽然++count是紧凑的语法却不是原子性操作.

###3.2.竞态条件(Race Condition)：
    概念：某个计算的正确性取决于多个线程的交替执行的时序时就发生了竞态条件.
        
        常见的竞态条件类型：“先检查后执行”，而检查条件可能在检查后执行动作的这段时间失效，就会出现很多问题.
        【例如：先检查一个文件是否存在，让后开始创建或写入文件,但是在创建或写入前可能另一个线程已经创建或者写入了文件】
    
    数据竞争(Data Race)：访问非final的域时没有采用同步机制,一个线程写入另一个线程读取且两个线程之间没有使用同步就会出现数据竞争.

###3.3.锁
    概念：只有在单个原子操作中更新状态才能保证一致性 
        
        - 同步方法存在性能问题

###3.4.重入
    概念：线程试图获得一个它已经持有的锁.【'线程'粒度的操作,POSIX线程的互斥体默认加锁行为是'调用'】
        
        实现：为每个锁关联一个计数器和所有者线程,JVM记下锁持有者并计数器+1,退出同步锁-1,
        例子：下面这种情况如果没有重入将发生死锁
            
            public class Widget{
                public synchronized void doSomething(){}
            }
            
            public class LoggingWidget extends Widget{
                public synchronized void doSomething(){		//获取Widget锁
                    super.doSomething();			//无法再获得Widget锁,死锁
                }
            }
            
    注意：在执行时间较长的计算或者可能无法快速完成的操作的时候一定不要持有锁.

###3.5.重排序
    概念：编译器,处理器可能会对操作的执行顺序进行意想不到的调整.
    
    例如： 
        main(){
            new ReaderThread().start();
            number = 42;
            ready = true;	//读线程可能在循环中读到ready=true开始读number的值,而number还没赋值为42,最后读到0
        }

###3.6.volatile变量
    概念：弱同步机制,不会将该变量的操作和其他内存操作一起重排序,也不会缓存在寄存器或其他处理器,保证所有操作的结果都是立即可见的.
        不会加锁,是一种比synchronized更轻量级的同步.
    
    注意：volatile保证操作的可见性，但不保证多线程写入的正确性，所以要慎重使用

    调试提示：对于服务器应用程序,启动JVM一定要指定-server选项,这比-client进行了更多的优化,例如讲循环中未被修改的变量提升到循环的外部.

###3.7.发布和逸出
    概念：就是类将私有数组变量等通过公有方法暴露,所有可使用该方法的线程都能修改这个数据,private定义也就没有意义了.































